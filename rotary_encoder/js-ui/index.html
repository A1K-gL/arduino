<!DOCTYPE html>
<html>
  <head>
    <title>Rotary Encoder Values</title>
    <link rel="stylesheet" href="css/style.css"/>
  </head>
  <body>
    <div class="container">
      <h1>Rotary Encoder Values</h1>
      <div class="widget-container">
        <div id="meter" class="gauge-container widget"></div>
        <div id="graph" class="widget"></div>  
      </div>
    </div>

    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="js/gauge.js"></script>
    <script>
      const sensorRange = Math.PI * 2.0

      const Gauge = window.Gauge;
      const meter = Gauge(document.getElementById("meter"), {
        min: -sensorRange,
        max: sensorRange,
        dialStartAngle: -90, 
        dialEndAngle: -90.01,        
        value: 0.0,
        label: v => (Math.round((180.0 * v / Math.PI) * 10) / 10.0) + "Â°"
      });

      let values = []      
   
      // set the dimensions and margins of the graph
      const margin = { top: 10, right: 30, bottom: 30, left: 60 },
        width = 500 - margin.left - margin.right,
        height = 300 - margin.top - margin.bottom;
      // append the svg object to the body of the page
      const svg = d3.select("#graph")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

      const xRange = width - 1;
        
      const x = d3.scaleLinear()
        .domain([0, xRange])
        .range([0, width]);

      const y = d3.scaleLinear()
        .domain([-sensorRange, sensorRange])
        .range([height, 0]);  
        
      svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));

      svg.append("g")
        .call(d3.axisLeft(y));
                   
      const makeXGridLines = () => d3.axisBottom(x).ticks(5)
      const makeYGridLines = () => d3.axisLeft(y).ticks(5)

      svg.append("g")			
        .attr("class", "grid")
        .attr("transform", "translate(0," + height + ")")
        .call(makeXGridLines().tickSize(-height).tickFormat(""))          

      svg.append("g")			
        .attr("class", "grid")
        .call(makeYGridLines().tickSize(-width).tickFormat(""))

      const path = svg.append("path")
        .attr("fill", "none")
        .attr("class", "line")

      const path2 = svg.append("path")
        .attr("fill", "none")
        .attr("class", "line2")

      const line = d3.line()
        .x(function (d, i) { return x(i) })
        .y(function (d) { return y(d[0]) }) 

      const line2 = d3.line()
        .x(function (d, i) { return x(i) })
        .y(function (d) { return y(d[1]) }) 


      const updateGraph = (data) => {
        path.attr("d", line(data))
        path2.attr("d", line2(data))
      }

      const socket = io()
      socket.on('data', (data) => {
        let [a, w] = data.split("\t").map(x => parseFloat(x))
        meter.setValue(a)
        values.push([a, w])
        values = values.slice(-xRange)
        updateGraph(values) 
      })        
      
  </script>

  </body>
</html>